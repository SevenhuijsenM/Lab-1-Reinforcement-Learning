                
                # for each possible move of the minotaur, compute the next state
                for minotaur_move in possibilities:
                    # Compute the next state given the current state and action (and minotaur move)
                    next_s = self.__move(s, a, minotaur_move);
                    
                    # Update the transition probabilities
                    transition_probabilities[next_s, s, a] = 1 / len(possibilities);


                    def print_maze_directions(directions):
    # Print the directions array using arrows
    for x in range(directions.shape[0]):
        for y in range(directions.shape[1]):
            print(" %s" % directions[x,y], end="")
        print();
    print();




    def draw_actions_position_minautar(env, policy, maze, minotaur_pos, t):
    # For each cell in the maze state that is not a wall, draw an arrow
    # corresponding to the action that would be taken when moving to that cell.

    # A variable containing the directions
    directions = np.zeros((maze.shape[0], maze.shape[1]), dtype=str);

    # For each cell in the maze
    for x in range(maze.shape[0]):
        for y in range(maze.shape[1]):
            # If the cell is not a wall
            if maze[x,y] != 1:
                # Get the index of this state
                state = env.map[((x,y), minotaur_pos)];
                # Get the action taken in this cell
                action = policy[state, t];
                # Depending on the action assign a direction
                if action == 0:
                    directions[x,y] = "s";
                elif action == 1:
                    directions[x,y] = "<";
                elif action == 2:
                    directions[x,y] = ">";
                elif action == 3:
                    directions[x,y] = "^";
                elif action == 4:
                    directions[x,y] = "v";
            else:
                directions[x,y] = "X";
    
    # Print an O  at the position of the minotaur
    directions[minotaur_pos[0], minotaur_pos[1]] = "O";

    # Print this array using a plot function
    print_maze_directions(directions);


    

maze = np.array([
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 2]
])

env = Maze(maze)

dynamic_programming(env, 10)

# # Try to simulate a move
# print(env.states[Maze._Maze__move(env, env.map[((0, 0), (1, 1))], env.MOVE_RIGHT, env.MOVE_RIGHT_MINOTAUR)])
 